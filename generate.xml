<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!--
  ~ Copyright (c) 2005, Gauntlet Systems Corporation. All Rights Reserved.
  -->
<generate-config>
    <destination-directory>../gorm/src</destination-directory>
    <extends>GauntletBean</extends>
    <password>bogus</password>
    <package>gsc.ci.ejb</package>
    <url>jdbc:postgresql://localhost:5432/gauntlet</url>
    <user>bt</user>
    
    <table>
        <class>User</class>
        <name>gauntlet_user</name>
    </table>
    <table>
        <class>Lock</class>
        <name>path_lock</name>
    </table>
    <table>
        <name>gauntlet_version</name>
	<skip>true</skip>
    </table>
    <table>
        <name>prev_succ_build</name>
	<skip>true</skip>
    </table>
    <table>
        <name>build_fixed_by</name>
	<skip>true</skip>
    </table>
    <table>
        <name>change</name>
        <relation>
          <name>id-svnlog</name>
          <xml-transient>false</xml-transient>
        </relation>
        <relation>
          <name>repository_id-repository</name>
          <xml-transient>false</xml-transient>
        </relation>
        <extra-body>
	public static final int PENDING = 1;
	public static final int TRUNK_COMMITTED = 2;
	public static final int SANDBOX_COMMITTED = 3;
        </extra-body>
    </table>
    <table>
        <name>module</name>
        <relation>
          <name>project_id-project</name>
          <xml-transient>false</xml-transient>
        </relation>
        <extra-body><![CDATA[
    public static void reassociateModules(Repository r) {
        for (Change change : r.getChangeList()) {
            reassociateModulesToChange(change);
        }
    }

    public static void reassociateModulesToChange(Change change) {
        java.util.Map<Integer, Module> modules = new java.util.HashMap<Integer, Module>();
        java.util.Map<String, Trunk> trunkMap = new java.util.HashMap<String, Trunk>();
        for (Trunk t : change.getRepository().getTrunkList()) {
            trunkMap.put(t.getPath(), t);
        }
        java.util.Collection<Trunk> changedTrunks = new java.util.HashSet<Trunk>();
        for (SvnlogPath path : change.getSvnlog().getSvnlogPathList()) {
            for (String trunkPath : trunkMap.keySet()) {
                String file = path.getPath();
                if (ensureEndsWithSlash(file).equals(trunkPath) || file.startsWith(trunkPath)) {
                    changedTrunks.add(trunkMap.get(trunkPath));
                }
            }
        }
        for (Trunk trunk : changedTrunks) {
            Module buildModule = trunk.getBuildModule();
            if (buildModule != null) {
                modules.put(buildModule.getId(), buildModule);
            }
            for (Module module : trunk.getModuleList()) {
                modules.put(module.getId(), module);
            }
        }
        change.setModuleList(modules.values());
    }

    public static String ensureEndsWithSlash(String path) {
        if (!path.endsWith("/")) {
            return path + "/";
        }
        return path;
    }
        ]]></extra-body>
   </table>
    <table>
        <name>build</name>
        <relation>
          <name>change_id-change</name>
          <xml-transient>false</xml-transient>
        </relation>
        <relation>
          <name>module_id-module</name>
          <xml-transient>false</xml-transient>
        </relation>
        <relation>
          <name>environment_id-environment</name>
          <xml-transient>false</xml-transient>
        </relation>
        <column>
            <name>log_clob</name>
            <xml-transient>true</xml-transient>
            <getter-access>private</getter-access>
            <setter-access>private</setter-access>
            <java-type>java.sql.Clob</java-type>
        </column>
        <column>
            <name>log</name>
            <xml-transient>true</xml-transient>
            <getter-access>private</getter-access>
            <setter-access>private</setter-access>
        </column>
        <column>
            <name>log_size</name>
            <setter-access>private</setter-access>
        </column>
      <extra-body>
    /** MAX size to store log as TEXT rather than CLOB
      * 100k seems reasonable threshold to start paging
      * out of 2453 gauntlet builds at this writing, 54
      * have logs greater than this
      */
    public static final int LOG_PAGE_SIZE = 1024 * 1024;
    @javax.persistence.Transient      
    public java.io.Reader getLogReader() throws java.sql.SQLException {
        java.io.Reader ret = null;
        Integer sz = getLogSize();
        if (sz != null) {
            if (sz.intValue() > LOG_PAGE_SIZE) {
                java.sql.Clob clob = getLogClob();
                if (clob != null) {
                    ret = clob.getCharacterStream();
                }
            } else {
                String log = getLog();
                if (log != null) {
                    ret = new java.io.StringReader(log);
                }
            }
        }
        return ret;
    }
    
    @javax.persistence.Transient      
    public void setLogReader(java.io.Reader rdr, int len) throws java.io.IOException {
        if (len > LOG_PAGE_SIZE) {
            setLog(null);
            if (rdr != null) {
                setLogClob(org.hibernate.Hibernate.createClob(rdr, len));
                setLogSize(len);
            } else {
                setLogClob(null);
                setLogSize(null);
            }
        } else {
            setLogClob(null);
            String log = null;
            if (rdr != null) {
                int nread = 0;
                int r;
                if (len > 0) {
                    char[] buf = new char[len];
                    try {
                        while ((r = rdr.read(buf, nread, len - nread)) > 0) {
                            nread += r;
                        }
                    } finally {
                        rdr.close(); // up to us to close it if not creating clob
                    }
                    if (nread != len) {
                        throw new java.io.IOException(
                          "expected " + len + " chars from stream but only got " + nread
                                );
                    }
                    log = new String(buf, 0, len);
                } else {
                    log = "";
                }
            }
            setLog(log);
            if (log != null) {
                setLogSize(len);
            } else {
                setLogSize(null);
            }
        }
    }
      </extra-body>            
    </table>
    <table>
        <name>coverage</name>
        <implements>ICoverage</implements>
    </table>
    <table>
        <name>coverage_package_report</name>
        <implements>ICoverage</implements>
    </table>
    <table>
        <name>coverage_srcfile_report</name>
        <implements>ICoverage</implements>
    </table>
    <table>
        <name>coverage_class_report</name>
        <implements>ICoverage</implements>
    </table>
    <table>
        <name>svnlog</name>
        <column>
            <name>commit_date</name>
            <field-name>date</field-name>
        </column>
        <column>
            <name>the_year</name>
            <field-name>year</field-name>
        </column>
    </table>
    <table>
        <name>svnlog_path</name>
        <column>
            <name>commit_action</name>
            <field-name>action</field-name>
        </column>
    </table>
    <table>
        <class>Work</class>
        <name>work_list</name>
        <column>
            <name>handler_ser</name>
            <field-name>handler</field-name>
            <xml-transient>true</xml-transient>
        </column>
    </table>
    <table>
        <name>data</name>
        <column>
            <name>bytes_field1</name>
            <xml-transient>true</xml-transient>
        </column>
        <column>
            <name>bytes_field2</name>
            <xml-transient>true</xml-transient>
        </column>
        <column>
            <name>bytes_field3</name>
            <xml-transient>true</xml-transient>
        </column>
    </table>
    <table>
        <name>test_result</name>
        <column>
            <name>duration</name>
            <field-name>time</field-name>
        </column>
        <relation>
            <name>test_id-test_case</name>
            <xml-transient>false</xml-transient>
        </relation>
    </table>
    <table>
        <name>suite_result</name>
        <column>
            <name>duration</name>
            <field-name>time</field-name>
        </column>
    </table>
    <table>
        <name>property</name>
        <extra-body>
	/** convenience accessor */
	@javax.persistence.Transient
	public String getName() {
	  String ret = null;
	  if (getMetaProperty() != null) {
	    ret = getMetaProperty().getName();
          }
	  return ret;
	}

	/** emulate boolean on top of int */
	@javax.persistence.Transient
        public Boolean getBooleanValue() {
	  Integer intVal = getIntValue();
	  if (intVal != null) {
	    return intVal.intValue() == 0 ? Boolean.FALSE: Boolean.TRUE;
	  }
	  return null;
	}
	public void setBooleanValue(Boolean b) {
	  Integer intVal = null;
	  if (b != null) {
	    if (b.booleanValue()) {
	      intVal = new Integer(1);
	    } else {
	      intVal = new Integer(0);
	    }
	  }
	  setIntValue(intVal);
	}

	/** opaque value based on property type: String|Integer|Boolean etc */
	@javax.persistence.Transient
	public Object getValue() {
	  Object ret = null;
	  MetaProperty mp = getMetaProperty();
	  if (mp != null) {
	    switch (mp.getDataType()) {
	      case MetaProperty.DATA_TYPE_INT: ret = getIntValue(); break;
	      case MetaProperty.DATA_TYPE_BOOL: ret = getBooleanValue(); break;
	      case MetaProperty.DATA_TYPE_FLOAT:
	      Integer intVal = getIntValue();
	      if (intVal != null) {
                ret = new Float((float) intVal.intValue()); break;
              }
	      case MetaProperty.DATA_TYPE_STRING:
	      case MetaProperty.DATA_TYPE_CLASS:
	      case MetaProperty.DATA_TYPE_PASSWORD:
	      case MetaProperty.DATA_TYPE_LARGE_STRING:
	      default:
                ret = getTextValue(); break;
	    }
	  }
          return ret;	  
	}

	/** convenience accessor for declaring object */
	@javax.persistence.Transient
	public Object getDeclaringObject() {
          Object ret = null;
          if (getSandbox() != null) {
            ret = getSandbox();
          } else if (getModule() != null) {
            ret = getModule();
          } else if (getProject() != null) {
            ret = getProject();
          } else if (getRepository() != null) {
            ret = getRepository();
          } else if (getEnvironment() != null) {
            ret = getEnvironment();
          } else if (getGauntletUser() != null) {
            ret = getGauntletUser();
          } else if (getRole() != null) {
	    ret = getRole();
	  }
	  return ret;
        }	
	</extra-body>
    </table>
    <table>
<!--
 name          | character varying(128) | not null
 type          | character varying(128) | not null
 scope         | character varying(32)  | not null
 data_type     | integer                | not null
 multi_value   | boolean                |
 default_value | text                   |
 default_int   | integer                |
 min_value     | integer                |
 max_value     | integer                |
 description
-->
        <name>meta_property</name>
        <column>
           <name>data_type</name>
           <xml-transient>true</xml-transient>
        </column>
        <column>
           <name>name</name>
           <xml-attribute-name>name</xml-attribute-name>
        </column>
        <column>
           <name>scope</name>
           <xml-attribute-name>scope</xml-attribute-name>
        </column>
        <column>
           <name>multi_value</name>
           <xml-attribute-name>multi-value</xml-attribute-name>
        </column>
        <column>
           <name>min_value</name>
           <xml-attribute-name>min-value</xml-attribute-name>
        </column>
        <column>
           <name>max_value</name>
           <xml-attribute-name>max-value</xml-attribute-name>
        </column>
        <column>
           <name>ptype</name>
           <field-name>type</field-name>
           <xml-attribute-name>property-type</xml-attribute-name>
        </column>
        <column>
           <name>default_value</name>
           <xml-element-name>default-value</xml-element-name>
        </column>
        <column>
           <name>default_int</name>
           <xml-element-name>default-int</xml-element-name>
        </column>
        <extra-body>
	/** enumeration of known property data types */
	public static final int DATA_TYPE_STRING = 0;
	public static final int DATA_TYPE_INT    = 1;
	public static final int DATA_TYPE_FLOAT  = 2;
	public static final int DATA_TYPE_BOOL   = 3;
	public static final int DATA_TYPE_CLASS  = 4;
	public static final int DATA_TYPE_PASSWORD = 5;
        /* for config UI: use textarea rather than one-liner field
         * for properties of this type
         */
	public static final int DATA_TYPE_LARGE_STRING  = 6;

	/** human-readable string of data type */
        @XmlAttribute(name = "data-type")
	@Transient
	public String getDataTypeName() {
	   String ret = null;
	   switch (getDataType()) {
	      case DATA_TYPE_STRING:
	      ret = "string"; break;
	      case DATA_TYPE_INT:
	      ret = "int"; break;
	      case DATA_TYPE_FLOAT:
	      ret = "float"; break;
	      case DATA_TYPE_BOOL:
	      ret = "boolean"; break;
	      case DATA_TYPE_CLASS:
	      ret = "classname"; break;
	      case DATA_TYPE_PASSWORD:
	      ret = "password"; break;
	      case DATA_TYPE_LARGE_STRING:
	      ret = "large_string"; break;
	      default:
	      ret = "error: unknown type: " + getDataType();
	      break;
	   }
	   return ret;
	}

        public void setDataTypeName(String s) {
            if ("string".equals(s)) {
               setDataType(DATA_TYPE_STRING);
            } else if ("int".equals(s)) {
               setDataType(DATA_TYPE_INT);
            } else if ("float".equals(s)) {
               setDataType(DATA_TYPE_FLOAT);
            } else if ("boolean".equals(s)) {
               setDataType(DATA_TYPE_BOOL);
            } else if ("classname".equals(s)) {
               setDataType(DATA_TYPE_CLASS);
            } else if ("password".equals(s)) {
               setDataType(DATA_TYPE_PASSWORD);
            } else if ("large_string".equals(s)) {
               setDataType(DATA_TYPE_LARGE_STRING);
            } else {
                throw new RuntimeException("unrecognized data type name: '" + s + "'");
            }
        }

	@Transient
        @XmlTransient
	public Boolean getDefaultBool() {
	   Integer I = getDefaultInt();
	   if (I != null) {
	       return (I.intValue() == 0) ? Boolean.FALSE: Boolean.TRUE;
	   } else {
	       return null;
           }
	}

	public void setDefaultBool(Boolean b) {
	   if (b != null) {
	      if (b.booleanValue()) {
	        setDefaultInt(1);
	      } else {
	        setDefaultInt(0);
	      }
	   } else {
	      setDefaultInt(null);
	   }
	}
	</extra-body>
    </table>
    <table>
        <name>coverage_method_report</name>
        <implements>ICoverage</implements>
        <relation>
            <name>id-test_result</name>
            <xml-transient>false</xml-transient>
        </relation>
        <relation>
            <name>coverage_method_id-coverage_method</name>
            <xml-transient>false</xml-transient>
        </relation>
        <extra-body>
    // dummy methods from ICoverage
    @Transient
    public Double getClassCoverage() {
        // TODO Auto-generated method stub
        return null;
    }
    @Transient
    public Integer getCoveredClasses() {
        // TODO Auto-generated method stub
        return null;
    }
    @Transient
    public Integer getTotalClasses() {
        // TODO Auto-generated method stub
        return null;
    }
    public void setClassCoverage(Double class_coverage) {
        // TODO Auto-generated method stub
        
    }
    public void setCoveredClasses(Integer covered_classes) {
        // TODO Auto-generated method stub
        
    }
    public void setTotalClasses(Integer total_classes) {
        // TODO Auto-generated method stub
        
    }
        </extra-body>
    </table>
</generate-config>
